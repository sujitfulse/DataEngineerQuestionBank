201	nulls and spaces in join keys  ? 

      val numbersDf = Seq(
        ("123"),
        ("456"),
        (null),
        ("")
      ).toDF("numbers")

      val lettersDf = Seq(
        ("123", "abc"),
        ("456", "def"),
        (null, "zzz"),
        ("", "hhh")
      ).toDF("numbers", "letters")

      val joinedDf = numbersDf.join(lettersDf, Seq("numbers"))
      +-------+-------+
      |numbers|letters|
      +-------+-------+
      |    123|    abc|
      |    456|    def|
      |       |    hhh|
      +-------+-------+
      // nulls are ignored

      numbersDf.join(lettersDf, numbersDf("numbers") <=> lettersDf("numbers"))
      +-------+-------+
      |numbers|letters|
      +-------+-------+
      |    123|    abc|
      |    456|    def|
      |   null|    zzz|
      |       |    hhh|
      +-------+-------+
      Spark provides a special NULL safe equality operator
-----------------------------------------------------------------------------------------------------------------------------------------------------------
202 Given a table with following columns:
School; Class; Student Name; Subject; Marks;
Sample Data:
+------+-----+------------+-------+-----+
|School|Class|Student Name|Subject|Marks|
+------+-----+------------+-------+-----+
|DPS   |9    |Sunil       |Maths  |90   |
|DPS   |9    |Sunil       |English|80   |
|DPS   |9    |Sunil       |Hindi  |87   |
|DPS   |9    |Sunil       |Science|83   |
|DPS   |10   |Sam         |Science|76   |
|DPS   |10   |Sam         |Hindi  |76   |
|DPS   |10   |Sam         |Maths  |76   |
|MVN   |9    |Happy       |Maths  |99   |
|MVN   |9    |Happy       |English|89   |
|MVN   |9    |Happy       |Hindi  |79   |
|MVN   |9    |Happy       |Science|78   |
+------+-----+------------+-------+-----+

Find Max marks and corresponding student name for subject 'Maths' for each class ?

==>

val classData = Seq(
("DPS","9","Sunil","Maths","90"),
("DPS","9","Sunil","English","80"),
("DPS","9","Sunil","Hindi","87"),
("DPS","9","Sunil","Science","83"),
("DPS","10","Sam","Science","76"),
("DPS","10","Sam","Hindi","76"),
("DPS","10","Sam","Maths","76"),
("MVN","9","Happy","Maths","99"),
("MVN","9","Happy","English","89"),
("MVN","9","Happy","Hindi","79"),
("MVN","9","Happy","Science","78")
).toDF("School","Class","Student Name","Subject","Marks")

import org.apache.spark.sql.expressions.Window
import org.apache.spark.sql.functions._

val classDataFiltered = classData.withColumn("math_rank", rank.over(Window.partitionBy(col("class"),col("Subject")).orderBy(col("marks").desc)))
scala> classDataFiltered.show(false)
+------+-----+------------+-------+-----+---------+
|School|Class|Student Name|Subject|Marks|math_rank|
+------+-----+------------+-------+-----+---------+
|DPS   |10   |Sam         |Hindi  |76   |1        |
|DPS   |9    |Sunil       |Hindi  |87   |1        |
|MVN   |9    |Happy       |Hindi  |79   |2        |
|DPS   |10   |Sam         |Science|76   |1        |
|DPS   |10   |Sam         |Maths  |76   |1        |
|MVN   |9    |Happy       |Maths  |99   |1        |
|DPS   |9    |Sunil       |Maths  |90   |2        |
|MVN   |9    |Happy       |English|89   |1        |
|DPS   |9    |Sunil       |English|80   |2        |
|DPS   |9    |Sunil       |Science|83   |1        |
|MVN   |9    |Happy       |Science|78   |2        |
+------+-----+------------+-------+-----+---------+

scala> classDataFiltered.where(" Subject == 'Maths' and math_rank==1").show(false)
+------+-----+------------+-------+-----+---------+
|School|Class|Student Name|Subject|Marks|math_rank|
+------+-----+------------+-------+-----+---------+
|DPS   |10   |Sam         |Maths  |76   |1        |
|MVN   |9    |Happy       |Maths  |99   |1        |
+------+-----+------------+-------+-----+---------+

----------------------------------------------------------------------------------------------------------------------------------------------------------

203 Write scala code for 
Given an array of elements, find a pair of numbers which has the maximum sum. OR  Print all pairs with given sum

A Initialize an empty hash set.
B Traverse through the array.
C For each element in the array, check if the difference between the sum and the current element exists in the hash set. If it exists, print the pair.
D Add the current element to the hash set.

import java.util.*;

public class Main {	
	public static void printPairs(int[] arr, int n, int sum) {
		Set<Integer> s = new HashSet<>();
		for (int i = 0; i < n; i++) {
			int temp = sum - arr[i];
			if (s.contains(temp)) {
				System.out.println("(" + temp + ", " + arr[i] + ")");
			}
			s.add(arr[i]);
		}
	}
	public static void main(String[] args) {
		int[] arr = {1, 5, 7, -1, 5};
		int sum = 6;
		int n = arr.length;
		printPairs(arr, n, sum);
	}
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------
221
Write a SQL query to find 3rd highest salary employee in each department, 
In case there are less than 3 emp in a dept then return emp with lowest salary in that Dept

+----+-------+------+
|dept|ename  |salary|
+----+-------+------+
|comp|Sunil  |10000 |
|comp|Anil   |8000  |
|comp|Swapnil|25000 |
|IT  |Ganesh |8300  |
|IT  |Mahesh |7600  |
|IT  |Jayesh |9000  |
|IT  |Dinesh |11000 |
|Mech|santa  |5000  |
|Mech|banta  |6000  |
|HR  |Neha   |60    |
+----+-------+------+

==> 

val empSalaryData = Seq(
("comp","Sunil",10000),
("comp","Anil",8000),
("comp","Swapnil",25000),
("IT","Ganesh",8300),
("IT","Mahesh",7600),
("IT","Jayesh",9000),
("IT","Dinesh",11000),
("Mech","santa",5000),
("Mech","banta",6000),
("HR","Neha",60)
).toDF("dept","ename","salary")

import org.apache.spark.sql.expressions.Window
import org.apache.spark.sql.functions._

val empSalaryDataRanked = empSalaryData.withColumn("salary_rank", rank.over(Window.partitionBy(col("dept")).orderBy(col("salary").desc))).
withColumn("total_emp", count(col("dept")).over(Window.partitionBy(col("dept"))))

empSalaryDataRanked.show(false)
+----+-------+------+-----------+---------+
|dept|ename  |salary|salary_rank|total_emp|
+----+-------+------+-----------+---------+
|HR  |Neha   |60    |1          |1        |
|IT  |Dinesh |11000 |1          |4        |
|IT  |Jayesh |9000  |2          |4        |
|IT  |Ganesh |8300  |3          |4        |
|IT  |Mahesh |7600  |4          |4        |
|Mech|banta  |6000  |1          |2        |
|Mech|santa  |5000  |2          |2        |
|comp|Swapnil|25000 |1          |3        |
|comp|Sunil  |10000 |2          |3        |
|comp|Anil   |8000  |3          |3        |
+----+-------+------+-----------+---------+

empSalaryDataRanked.where(" (total_emp>=3 and salary_rank=3)  or (total_emp < 3 and salary_rank=total_emp) ").show(false)
+----+------+------+-----------+---------+
|dept|ename |salary|salary_rank|total_emp|
+----+------+------+-----------+---------+
|HR  |Neha  |60    |1          |1        |
|IT  |Ganesh|8300  |3          |4        |
|Mech|santa |5000  |2          |2        |
|comp|Anil  |8000  |3          |3        |
+----+------+------+-----------+---------+
-----------------------------------------------------------------------------------------------------------------------------------------------------------
221 We have a static collection of data in which first row is always a number of records in a collection, On second row u have a name,age,city. 
You have to remove duplicates with respect to name and age 
In a such a way that city value should get replaced and print data. 
[5,Sunil,28,pune,anil,32,latur,Sunil,28,nanded,Jayesh,28,nashik,Mahesh,30,Nashik]

import scala.collection.mutable.HashMap 
object HelloWorld {
	def main(args: Array[String]): Unit = {
	  
	  val dataList: List[String] = List("5","Sunil","28","pune","anil","32","latur", 
	  "Sunil","28","nanded","Jayesh","28","nashik","Mahesh","30","Nashik");

	 var hashMap = HashMap[String, String]()
		for ( i <- 1 to (dataList.length -1) by 3){
		  hashMap = hashMap + ( (dataList(i) +","+dataList(i+1) )->dataList(i+2))   
		}

		 hashMap.foreach{case (key, value) => println (key + " -> " + value)}
	}
}

// output 

Jayesh,28 -> nashik
anil,32 -> latur
Sunil,28 -> nanded
Mahesh,30 -> Nashik

------------------------------------------------------------------------------------------------------------------------------------------------------------
222  code for 
1) prime num 

class gfg {
    static void prime_N(int N)
    {
        // Declaring the variables
        int x, y, flg;
        // Using for loop for traversing all
        for (x = 1; x <= N; x++) {
            // Omit 0 and 1 as they are  neither prime nor composite
            if (x == 1 || x == 0) {
                continue; 
            }
 
            // Using flag variable to check if x is prime or not
            flg = 1;
 
            for (y = 2; y <= x / 2; ++y) {
                if (x % y == 0) {
                    flg = 0;
                    break;
                }
            }
 
            // If flag is 1 then x is prime but
            // if flag is 0 then x is not prime
            if (flg == 1)
                System.out.print(x + " ");
        }
    }
 
    // The Driver code
    public static void main(String[] args)
    {
        int N = 45;
        prime_N(N);
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
2) Fibonacci series 
// Java program for the above approach

class GFG {
	// Function to print N Fibonacci Number
	static void Fibonacci(int N)
	{
		int num1 = 0, num2 = 1;
		int counter = 0;
		// Iterate till counter is N
		while (counter < N) {
			// Print the number
			System.out.print(num1 + " ");
			// Swap
			int num3 = num2 + num1;
			num1 = num2;
			num2 = num3;
			counter = counter + 1;
		}
	}

	// Driver Code
	public static void main(String args[])
	{
		// Given Number N
		int N = 10;
		// Function Call
		Fibonacci(N);
	}
}

scala :  def fibonacci(n :Int) : Int =   if (n<=2) 1 else fibonacci(n-1)+fibonacci(n-2)
------------------------------------------------------------------------------------------------------------------------------------------------------------

3) Higher order function lambda function to Sum even numbers from 1 to 100
4) reverse string without using inbuilt api
5) Sort array without using sort function

------------------------------------------------------------------------------------------------------------------------------------------------------------
223) Calculate Factorial, Fibonacci, Prime no -

object calculate {
  
  // factorial 1*2*3...*n 
  def factorial(n : Int) : Int =  if(n==1) 1  else n * factorial(n-1)
  
    // factorial 1*2*3...*n 
  def factorialTailRecursion(n : Int) : BigInt =  { 
    def factorialTailRecursionAux(n : Int,acc : BigInt):BigInt = { 
        if(n<=1) acc  else  factorialTailRecursionAux(n-1,n * acc)
    }
    factorialTailRecursionAux(n,1)
}

  def fibonacci(n :Int) : Int =   if (n<=2) 1 else fibonacci(n-1)+fibonacci(n-2)
  // 1,1,2,3,5,8,13,21

  def isprimeNum(n:Int):Boolean = {
    def isprimeNumUntill(t:Int):Boolean = if( t <= 1)  true   else n%t != 0 && isprimeNumUntill(t-1)
   isprimeNumUntill(n/2)
  }
  
	def main(args: Array[String]): Unit = {
    println(factorial(10))
    println(factorialTailRecursion(5000))
    println(fibonacci(8)) // returns fibonacci of 5. means 5th number in series
    println(isprimeNum(7))
	}
}
------------------------------------------------------------------------------------------------------------------------------------------------------------
223) Caculate factorial , concat words, is number prime, fibonacchi using tail recursion

object calculate {
  
    // factorial 1*2*3...*n 
  def factorialTailRecursion(n : Int) : BigInt =  { 
    def factorialTailRecursionAux(n : Int,acc : BigInt):BigInt = { 
        if(n<=1) acc  else  factorialTailRecursionAux(n-1,n * acc)
    }
    factorialTailRecursionAux(n,1)
}

 // print string n times using tail recursion 
 def concatString(word: String,cnt:Int ):String = {
    def concatStringAuxTailRec(word: String,newWord:String,count:Int ):String = {
      if (count == 0) newWord 
      else concatStringAuxTailRec(word ,word.concat(newWord), count-1 )
    }
   concatStringAuxTailRec(word,"",cnt)
 }
  
  // check if num is prime using tail recursion 
   def isPrime(num: Int):Boolean = {
    def isPrimeTailRec(tempNum:Int,count:Int,isBoolean:Boolean):Boolean = {
      if(count<=2) isBoolean 
      else isPrimeTailRec(tempNum,count -1,(tempNum %(count -1) != 0) &&  isBoolean)   
    }
     isPrimeTailRec(num,num/2,true)
   }
  
  //fibonacchi using tail recursion 1,1,2,3,5,8,14,21
  
     def fibonacchiRecu(n: Int):Int = {
    def fibonacchiTainRecu(i:Int,last:Int,lastToLast:Int):Int = 
      if(n <= i) last
      else fibonacchiTainRecu(i+1,last+lastToLast, last)
    
      if(n <= 2) 1
      else  fibonacchiTainRecu(2,1, 1)
   }

	def main(args: Array[String]): Unit = {
    println(factorialTailRecursion(10))
    println(concatString("sujit",5)) 
    println(isPrime(7))
    println(isPrime(8))
     println(fibonacchiRecu(8))
   
	}
}
